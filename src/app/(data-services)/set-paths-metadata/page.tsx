"use client";
import { useGlobalState } from "@/contexts/AppContext";
import {
    ApiData,
    Frequency as FrequencyVal,
    AnalyticsDataType as AnalyticsDataTypeVal,
} from "@/types/types";
import {
    Flex,
    chakra,
    Menu,
    MenuButton,
    MenuList,
    MenuItem,
    Button,
    useToast,
} from "@chakra-ui/react";
import { useRouter } from "next/navigation";
import React, { useEffect, useState } from "react";
import type { MetadataForData, TimeRange } from "@/types/types";
import { useGoHome } from "@/hooks/useGoHome";
import {
    formatDateForInputElem,
    fromAnalyticsDataTypeGetString,
    fromFreqGetString,
    fromStringGetAnalyticsDataType,
    fromStringGetFreq,
} from "src/utils/utils";
import { ChevronDownIcon } from "@chakra-ui/icons";

function SetPathsMetadataPage() {
    useGoHome({
        condition: (state) =>
            !state.selectedApiData || state.selectedApiData.length === 0,
    });
    const { appState, dispatch } = useGlobalState();
    const toast = useToast();
    const router = useRouter();
    console.log("Rendering with state: ", appState)
    useEffect(() => {
        let ignore = false;
        if (!ignore) {
            const body = JSON.stringify({
                descriptions: appState?.selectedApiData.map((f) => f.description),
            });
            fetch("/api/generate-analytics-types", {
                method: "POST",
                body,
            })
                .then((res) => {
                    console.log("The response was: ", res);
                    return res.json() as Promise<boolean[]>;
                })
                .then((data) => {
                    console.log("The data is: ", data);
                    const analyticsTypes = data.map((d) => {
                        if (d) {
                            return AnalyticsDataTypeVal.REALTIME;
                        } else {
                            return AnalyticsDataTypeVal.HISTORICAL;
                        }
                    });
                    const updatedApiData = appState?.selectedApiData.map((data, index) => {
                        return { ...data, analyticsDataType: analyticsTypes[index] }
                    })
                    //@ts-expect-error
                    dispatch({ type: "set-api-data-with-metadata", payload: updatedApiData })
                    toast({
                        position: "top-right",
                        title: "AI Generation",
                        description: "The pre-filled data was generated by AI",
                        duration: 3000,
                        status: "info"
                    })
                });
        }

        return () => {
            ignore = false;
        };
    }, []);

    const handleMetadataChange = (index: number, data: Partial<MetadataForData>) => {
        //@ts-expect-error
        dispatch({ type: "set-api-data-elem-with-metadata", payload: { index, data } })
    }

    const handleSubmit = () => {
        console.log("State before submitting", appState?.selectedApiData)
        if (!appState?.selectedApiData?.length) {
            console.log("Show popup to user");
            toast({
                title: "Validation Failed",
                description: "You havent submitted a frequency for each of the apis",
                status: "error",
                duration: 5000,
                isClosable: true,
            });
        } else {
            toast({
                description: "Updating the Metadata for the Data Sources was successful",
                status: "success",
                duration: 5000,
                isClosable: true,
            });
            router.push("connect-with-layouts")
            console.log("Everything is set go to next page");
        }
    };
    return (
        <Flex
            flexDir="column"
            w="100vw"
            h="100vh"
            rowGap={"1rem"}
            alignItems={"center"}
            paddingTop="1rem"
            px="2.5rem"
        >
            {appState?.selectedApiData.map((apiData, index) => {
                return (
                    <ApiPathComponent
                        key={apiData.identification}
                        data={apiData}
                        handleChange={handleMetadataChange}
                        labelFromTime="From Date"
                        labelToTime="To Date"
                        labelFrequency={fromFreqGetString(apiData.frequency)}
                        labelAnalyticsType={fromAnalyticsDataTypeGetString(apiData.analyticsDataType)}
                        index={index}
                    />
                );
            })}
            <Button w="35%" onClick={(e) => handleSubmit()}>
                Submit
            </Button>
        </Flex>
    );
}

interface EditApiPathProps {
    data: ApiData;
    handleChange: (index: number, metadata: Partial<MetadataForData>) => void;
    labelFrequency: string;
    labelToTime: string;
    labelFromTime: string;
    labelAnalyticsType: string;
    index: number;
}

const DEFAULT_TIME_RANGE: TimeRange = {
    from: new Date(),
    to: new Date(),
};
function ApiPathComponent({
    data,
    handleChange,
    labelFrequency,
    labelToTime,
    labelFromTime,
    index,
    labelAnalyticsType,
}: EditApiPathProps) {

    // const [dateState, setDateState] = useState<TimeRange>({ from: new Date(), to: new Date() })

    // const [fromDate, setFromDate] = useState<string>(
    //     DEFAULT_TIME_RANGE.from.toDateString()
    // );
    // const [toDate, setToDate] = useState<string>(
    //     DEFAULT_TIME_RANGE.to.toDateString()
    // );
    // const setDates = (date:string,isFrom:boolean) => {
    //     handleChange(index, {
    //         range: { from: new Date(fromDate), to: new Date(toDate) },
    //     });
    // };

    console.log("For the api path component:", data, labelAnalyticsType);
    //++ add Validation that the two dates are properly set
    //fromDate is before toDate
    const handleDateChange = (date: string, isFrom: boolean): void => {
        console.log("Changing Date to: ", date, isFrom);
        if (isFrom) {
            handleChange(index, {
                //@ts-expect-error
                range: { to: data.range?.to, from: new Date(date) }
            })
        } else {
            handleChange(index, {
                //@ts-expect-error
                range: { to: new Date(date), from: data.range?.from }
            })
        }
        // setDates();
    };
    return (
        <Flex
            py="0.5rem"
            px="1rem"
            w="100%"
            key={data.identification}
            columnGap={"1.5rem"}
            border="solid black 1px"
        >
            <chakra.span fontWeight={"bold"}>
                Description:{" "}
                <chakra.span fontWeight={"initial"}>{data.description}</chakra.span>
            </chakra.span>
            <chakra.span fontWeight={"bold"}>
                Id:{" "}
                <chakra.span fontWeight={"initial"}>{data.identification}</chakra.span>
            </chakra.span>
            <Menu>
                <MenuButton
                    data-test-id="frequency-menu"
                    as={Button}
                    rightIcon={<ChevronDownIcon />}
                >
                    {labelFrequency || "Frequency"}
                </MenuButton>
                <MenuList>
                    {Object.keys(FrequencyVal).map((d) => {
                        return (
                            <MenuItem
                                data-test-id={`frequency-${d}`}
                                key={d}
                                onClick={(e) =>
                                    handleChange(index, { frequency: fromStringGetFreq(d) })
                                }
                            >
                                {d}
                            </MenuItem>
                        );
                    })}
                </MenuList>
            </Menu>
            {/* use the labels provided */}
            {/* this does not work properly as it is not rerendering when changing value */}
            <chakra.label fontWeight="bold" alignSelf={"center"}>From Date: </chakra.label>

            <input
                type="date"
                value={formatDateForInputElem(data.range?.from)}
                onChange={(e) => handleDateChange(e.target.value, true)}
            />
            <chakra.label fontWeight="bold" alignSelf={"center"}>To Date: </chakra.label>

            <input
                type="date"
                value={formatDateForInputElem(data.range?.to)}
                onChange={(e) => handleDateChange(e.target.value, false)}
            />
            <Menu>
                <MenuButton
                    data-test-id="frequency-menu"
                    as={Button}
                    rightIcon={<ChevronDownIcon />}
                >
                    {labelAnalyticsType || "Analytics Type"}
                </MenuButton>
                <MenuList>
                    {Object.keys(AnalyticsDataTypeVal).map((d) => {
                        return (
                            <MenuItem
                                data-test-id={`analytics-type-${d}`}
                                key={d}
                                onClick={(e) =>
                                    handleChange(index, {
                                        analyticsDataType: fromStringGetAnalyticsDataType(d),
                                    })
                                }
                            >
                                {d}
                            </MenuItem>
                        );
                    })}
                </MenuList>
            </Menu>

            {/* analyticsTypesWereGeneratedByAI && "<- Generated By AI" */}
        </Flex>
    );
}

export default SetPathsMetadataPage;
